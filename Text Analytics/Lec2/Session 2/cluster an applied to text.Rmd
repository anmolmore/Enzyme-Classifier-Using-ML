---
title: "Cluster An funcs applied to text data"
output: html_document
---

## Introduction

Previously, we saw: 
+  (i) what cluster-an is, 
+  (ii) what cluster-an does.

Now we will see:
+  (iii) how to find the optimal number of clusters, 
+  (iv) how to interpret the results via tables and/or displays.  

Time now to extend that primer wala learning to actual text, then. Some Qs to think about: 
*  [1] What might cluster-an on text data *mean*? 
*  [2] On what text data objects would you apply it? 
*  [3] What kind of result displays would be most meaningful and helpful for interpretation purposes? 
*  [4] Etc.  

In what follows, I present a short markdown guide on applying cluster-an principles to text. In the process, I also demonstrate the use of the `source()` func which enables us to read in previously created funcs directly into our workspace, the use of piping to chain together functions into one seamless workflow etc, on a small scale.   

Behold.  

```{r setup}
## setup
rm(list=ls())    # clear workspace

# set wd to enable use of relative paths
setwd("C:\\Users\\31172\\TABA\\Session 2\\");  getwd()  

# sourcing in our session 1 funcs directly into R
suppressPackageStartupMessages({
source("https://raw.githubusercontent.com/sudhir-voleti/code-chunks/master/cba%20tidytext%20funcs%20for%20git%20upload.R")
  })

```

Notice how the use of `source()` enabled us to fill our workspace with yesterday's funcs. COnsider the possibilities that entails in expanding domain, sharing workflows and collaborating on complex projects across teams using github's full functionalities ...  

OK, back to cluster-an. First things first. How many clusters are there in the solution? We'll use **scree plots** to find that out. The func below applies on DTMs.  

Another thing about the test data we'll be using here. This is a 2008 websurvey based primary data collected from 5000+ regular shoppers at a mid-sized regional US supermarket chain.  

The retailer was launching a store brand line of ice-creams and the survey Q being analyzed asked respondents "Which flavors of ice cream do you prefer?".

## Func 1: build scree plot to find optimal #clusters
```{r kmeans.scree}

build_kmeans_scree <- function(mydata)  # rows are units, colms are basis variables
{ # Determine number of clusters
set.seed(seed = 0000)   # set seed for reproducible work
wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))  # wss is within group sum of squares

for (i in 2:15) wss[i] <- sum(      # checking model fit for 2 to 15 clusters
                            kmeans(mydata,  centers = i)$withinss)  # note use of kmeans() func

plot(1:15, wss, type="b",  # scree.plot = 
	     xlab="Number of Clusters",
	     ylab="Within groups sum of squares")

 } # func ends

# test-driving func 1 with ice-cream data
ice_cream = readLines("./ice-cream data.txt");    length(ice_cream)

# piping together sourced funcs into a single workflow. :)
system.time({ dtm_ice_cream = ice_cream %>% text.clean() %>% dtm_build() })  # 1.33 secs

dim(dtm_ice_cream)    # [1] 2208  922
system.time({ build_kmeans_scree(dtm_ice_cream) })   # 7.53 secs. Say k=8 clusters is optimal (illustrative)
```
Again, above, I want to point out the use of piping to chain together distinct funcs.  

From the scree plot, we identify the optimal k. Next, below, we divide the DTM into cluster-wise pieces and display each for interpretation purposes.

## Func 2: build display aids to view what the text-based clusters are
```{r display.clus}
display.clusters <- function(dtm, k)  # k=optimal num of clusters
{ 

  # K-Means Cluster Analysis
  fit <- kmeans(dtm, k) # k cluster solution

 for (i1 in 1:max(fit$cluster)){ 
#	windows()
	dtm_cluster = dtm[(fit$cluster == i1),] 
	distill.cog(dtm_cluster) 	} # i1 loop ends

 }  # func ends

 # test driving the func
 system.time({ display.clusters(dtm_ice_cream, 3) })
```

OK. Dassit for this markdown. Back to the slides, class.

Sudhir
