---
title: "Building Shiny Apps"
author: "A Pandey and S Voleti"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Shiny* is an R package for building interactive web applications using R, as also *dashboards*. Developed by Yihui Xie and the Rstudio team, it comes with ample tutorial materials for building shiny apps, including [video and written tutorials.](https://shiny.rstudio.com/tutorial/)

Shiny works *only* in RStudio. If you haven't installed shiny package yet, do so. 

```{r,eval=FALSE, echo=T}
if (!require(shiny)) {install.packages('shiny')}
```

## Structure of a Shiny App

Shiny apps cab be structured in *two** ways:   

+  [1] Using 2 scripts called *ui.R* and *server.R*. (For complex apps you can have more scripts in addition to these two scripts). 
*ui.r* script controls app layout, appearance, interaction options whereas *server.R* has all the back-end computational instructions. These two scripts *must** reside in one single directory and the app can be run from Rtudio directly. See the image below.


![](https://raw.githubusercontent.com/aashishkpandey/datasets/master/image1.png "Run App")
  
      
+  [2] The app can be written in a single script called *app.R*residing in a directory (for example, newdir/) and run with `runApp("newdir")`.

`app.R` has three components:   
+  [1] a user interface object,   
+  [2] a server function, and   
+  [3] a call to the shinyApp function. 

FIrst, let's see the first approach.

## ui.R script

First, load all the required packages for the app including `shiny`.  In what follows, just read the ui.R script file line by line and correspond with the funcs below.  
  
+  After that we can call the function `shinyUI()` and define the appearance of our app.   
    
+  Next, the function `fluidPage()` defines a dynamic application layout enabling the app to automatically fit a screen size.  
  
+  Next, the function `titlePanel()` creates a panel containing an application title.  

+ Then, function `sidebarLayout` creates a layout with a sidebar and main area. The sidebar is displayed with a distinct background color and typically contains input controls. The main area occupies 2/3 of the horizontal width and typically contains outputs.  

+  function `sidebarPanel()` creates a sidebar panel containing input controls such `selectInput`, `numericInput`, `sliderInput`, `dateInput` etc.   
  
+  function `mainPanel()` creates a main panel containing output elements, typically structured in *tabs*, i.e.,  multiple independently viewable sections.   
 
+  function `tabsetPanel()` creates a set of tabs with *tabPanel* elements.   
  
+  function `tabPanel()` creates a tab panel that can be included within a tabsetPanel.

### Output Types

The app takes user input from the sidebar panel, processes it in the back-end and then typically displays output in the main area in the form of tables, charts, graphs, plain text, downloadable files, etc.  

Shiny provides a family of functions that turn R objects into output for your user interface. Each function creates a specific type of output.

**Output function** ------------>	   **Creates**<br>
dataTableOutput     ------------>      DataTable<br>
htmlOutput          ------------>       raw HTML<br>
imageOutput         ------------>       image<br>
plotOutput          ------------>        plot<br>
tableOutput         ------------>         table<br>
textOutput          ------------>         text<br>
uiOutput            ------------>        raw HTML<br>
verbatimTextOutput  ------------>	    text<br>

## Coding a live example

Suppose we want to build a small, simple shiny app first. The aim is the following:  

+  to take a matrix as input,   
+  run kmeans on it,   
+  select the optimal number of clusters from a scree plot,  
+  view a summary table of cluster means, and   
+  view the resulting clustering assignment.   

Below lies `ui.R` script code for the above.  

P.S. Launch the app and match the funcs below with what you see on the app itself.  

```{r, eval= FALSE, echo=TRUE}
library("shiny")

shinyUI(
  fluidPage(
    
    titlePanel("k-means Clustering"),  # name the shiny app
    
    sidebarLayout(    # creates a sidebar layout to be filled in
      
      sidebarPanel(   # creates a panel struc in the sidebar layout
        
        # user reads input file into input box here:
        fileInput("file1", 
                  "Upload data (csv file with header)"),
        
        # user selects the optimal num of clusters:
        numericInput('clusters', 
                     'Number of Clusters', 
                     3,   # default value required
                     min = 1, max = 9)     
        
        ),   # end of sidebar panel
      
    ## Main Panel area begins.
      mainPanel(
        
        tabsetPanel(type = "tabs",   # builds tab struc
                    
                    tabPanel("Overview",   # leftmost tab
                             
                             h4(p("Data input")),
                             
                             p("This app supports only comma separated values (.csv) data file. CSV data file should have headers and the first column of the file should have row names.", align="justify"),
                             
                             p("Please refer to the link below for sample csv file."),
                             a(href="https://github.com/sudhir-voleti/sample-data-sets/blob/master/Segmentation%20Discriminant%20and%20targeting%20data/ConneCtorPDASegmentation.csv"
                               ,"Sample data input file"),   
                             
                             br(),
                             
                             h4('How to use this App'),
                             
                             p('To use this app, click on', 
                               span(strong("Upload data (csv file with header)")),
                               'and uppload the csv data file. You can also change the number of clusters to fit in k-means clustering')),
                    
                    # second tab coming up:
                    tabPanel("Scree plot", 
                             
                             # plot1 object returned by server.R
                             plotOutput('plot1')),
                    
                    # third tab coming up:
                    tabPanel("Cluster mean",
                             
                             # obj 'clust_summary' from server.R
                             tableOutput('clust_summary')),
                    
                    # fourth tab coming up:
                    tabPanel("Data",
                             
                             dataTableOutput('clust_data'))
                    
        ) # end of tabsetPanel
      )# end of main panel
    ) # end of sidebarLayout
  )  # end if fluidPage
) # end of UI

```

## server.R demo

Any server.R script always starts with function `shinyServer()`.   
  
It defines the server-side logic of the Shiny application. This generally involves creating functions that map user inputs to various kinds of output.

### Interactivity and the Render func

Beyond just automating workflows (which sourced funcs could do just as well), what gives shiny an edge is *interactivity*. Users can interact with the app by changing inputs and expect the app to *react* by *rendering* corresponding changes in output.

Hence, each output object **must** contain the output of one of Shiny's `render()` functions.   
  
These functions capture an R expression and do some light pre-processing on the expression. Use the *render* function that corrresponds to the type of *reactive* object you are making.

<br>
**render function**  ------------>		**creates**<br>
renderDataTable	 ------------>	DataTable<br>
renderImage	 ------------>	images (saved as a link to a source file)<br>
renderPlot	 ------------>	plots<br>
renderPrint	 ------------>	any printed output<br>
renderTable	 ------------>	data frame, matrix, other table like structures<br>
renderText	 ------------>	character strings<br>
renderUI	  ------------>	a Shiny tag object or HTML<br>
<br>

Each `render` function takes a single argument: an R expression surrounded by braces, `{}`.   
  
The expression can be one simple line of text, or it can involve many lines of code, as if it were a complicated function call. Behold.  

```{r, eval=F, echo=TRUE}
shinyServer(function(input, output) {
  
  Dataset <- reactive({
    
    if (is.null(input$file)) { return(NULL) } else
      {
        
      Data <- as.data.frame(
        read.csv(input$file1$datapath, 
                 header=TRUE, sep = ","))
      
      rownames(Data) = Data[,1]
      
      Data1 = Data[,2:ncol(Data)]
      
      return(Data1)
    }  # else stmt ends
    
  })  # reactive stmt ends
  
  # 'plot1' is output obj for tab 2:
  output$plot1 = renderPlot({ 
    
    data.pca <- prcomp(Dataset(),center = TRUE,scale. = TRUE)
    plot(data.pca, type = "l"); abline(h=1)    

      })
  
  clusters <- reactive({
    
    kmeans(Dataset(), input$clusters)  # user inputs num clusters.
  
    })
  
  # 'clust_summary' is outp obj for tab 3:
  output$clust_summary = renderTable({
    
    out = data.frame(
      Cluser = row.names(clusters()$centers), 
      clusters()$centers)
    out
    
    })
  
  # 'clust_data' is outp obj for last tab:
  output$clust_data = renderDataTable({
    
    out = data.frame(
      row_name = row.names(Dataset()), 
      Dataset(),
      Cluster = clusters()$cluster)
    
    out
  
    })
  
})  # server.R file ends
```

## app.R demo

To create shiny app using single script, define ui and server functions, as shown above, into a single script file `app.R` and in the end of script call shinyApp function. See the example below for app.R script. 

```{r, eval=FALSE, echo=TRUE}

#---------------------------------------------------------------------#
#               k-means Clustering App                               #
#---------------------------------------------------------------------#

library("shiny")

# Define ui function
ui <- shinyUI(
  fluidPage(
    
    titlePanel("k-means Clustering"),
    
    sidebarLayout( 
      
      sidebarPanel(  
        
        fileInput("file", "Upload data (csv file with header)"),
        
        numericInput('clusters', 'Number of Clusters', 3,
                     min = 1, max = 9)     ),   # end of sidebar panel
      
      
      mainPanel(
        
        tabsetPanel(type = "tabs",
                    
                    tabPanel("Overview",
                             h4(p("Data input")),
                             p("This app supports only comma separated values (.csv) data file. CSV data file should have headers and the first column of the file should have row names.",align="justify"),
                             p("Please refer to the link below for sample csv file."),
                             a(href="https://github.com/sudhir-voleti/sample-data-sets/blob/master/Segmentation%20Discriminant%20and%20targeting%20data/ConneCtorPDASegmentation.csv"
                               ,"Sample data input file"),   
                             br(),
                             h4('How to use this App'),
                             p('To use this app, click on', 
                               span(strong("Upload data (csv file with header)")),
                               'and uppload the csv data file. You can also change the number of clusters to fit in k-means clustering')),
                    tabPanel("Scree plot", 
                             plotOutput('plot1')),
                    
                    tabPanel("Cluster mean",
                             tableOutput('clust_summary')),
                    
                    tabPanel("Data",
                             dataTableOutput('clust_data'))
                    
        ) # end of tabsetPanel
      )# end of main panel
    ) # end of sidebarLayout
  )  # end if fluidPage
) # end of UI


# Define Server function
server <- shinyServer(function(input, output) {
  
  Dataset <- reactive({
    if (is.null(input$file)) { return(NULL) }
    else{
      Data <- as.data.frame(read.csv(input$file$datapath ,header=TRUE, sep = ","))
      rownames(Data) = Data[,1]
      Data1 = Data[,2:ncol(Data)]
      return(Data1)
    }
  })
  
  output$plot1 = renderPlot({ 
    data.pca <- prcomp(Dataset(),center = TRUE,scale. = TRUE)
    plot(data.pca, type = "l"); abline(h=1)    
  })
  
  clusters <- reactive({
    kmeans(Dataset(), input$clusters)
  })
  
  output$clust_summary = renderTable({
    out = data.frame(Cluser = row.names(clusters()$centers),clusters()$centers)
    out
  })
  
  output$clust_data = renderDataTable({
    out = data.frame(row_name = row.names(Dataset()),Dataset(),Cluster = clusters()$cluster)
    out
  })
  
})

# Now call shinyApp function
shinyApp(ui = ui, server = server)
```

The above is an illustrative small app we live-built in class. One can think of adding more user-input widgets and options, inserting more output objects and tabs and correspondingly more back-end server side analyses.  

One can also thereafter host both ui.R and server.R files in github from where a `runGithub()` func from shiny can read the code into a live Rstudio session and render the app live.  

With that, this demo ends. I hope you are prepared for some (relatively simple) shiny app constructions in your hoework assignments. :)

Ciao

Sudhir
