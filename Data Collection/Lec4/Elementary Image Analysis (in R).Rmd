---
title: "Elementary Image Analysis (in R)"
output: html_document
---
### Introduction and Background

Images constitute an important part of semi-structured data collection. But what to do with the collected set of images? How to understand, process and analyze them for meaningful insight?

Hence, here, we journey to explore provide some elementary analysis tools in this notebook. The keyword being elementary.

Also, we're using two popular packages from R for this one - EBImage and imager.

**EBImage** provides general purpose functionality for image processing and analysis, especially for researchers in the life sciences doing work with gene expression arrays, tissue samples etc. In fact, quoting from EBImage's vignette:

In the context of (high-throughput) microscopy-based cellular assays, EBImage offers tools to segment cells and extract quantitative cellular descriptors. This allows the automation of such tasks using the R programming language and facilitates the use of other tools in the R environment for signal processing, statistical modeling, machine learning and visualization with image data.

See basic documentation and installation instructions for it,[here.] (https://www.bioconductor.org/packages/release/bioc/html/EBImage.html)

**imager** is a CRAN package for image and video processing functions. We'll see a few on the way.

```{r}
## Setup chunk

suppressPackageStartupMessages ({
  
  if (!requireNamespace("BiocManager", quietly = TRUE)) { install.packages("BiocManager") }
  if (!require(EBImage)) { BiocManager::install("EBImage", version = "3.8")} 
  library(EBImage)
  
  if (!require(imager)){install.packages("imager")}
  library(imager)
  
})

setwd = "."
getwd()

```

Change your setwd() path. There are some demo images put in the LMS folder. Let's use them to:

* Read images into R
* Discern storage structures [3-D arrays] for image files in R
* Display images
* Basic image manipulations like grayscale, resizing, combining etc.

```{r}
# Read Image
library(EBImage)
Image1 <- readImage("data/isb.jpg")
Image2 <- readImage("data/jantar_mantar.jpg")

# What are images stored as? use 'print()'
print(Image1)
cat('\n')
print(Image2)
```
Note above:

Images in R stored as 3-D arrays containing floating-point numbers. Each number represents a pixel value. 3 layers of pixels corresponding to primary colors Red, Green and Blue (RGB) are superimposed to create color effects at each point in the image.

The dimension of an image is given as [w x h x RGB]. In R the numbers range from 0-1 whereas in openCV and py, they range from 0-255.

Larger images have more pixels. Which of the two images above is larger? To make proper comparisons, perhaps its better to resize images to the same dimension? Try ?EBImage::resize coz imager also has a resize option, so must specify package.

We'll later also use the regular summary func on the numeric arrays representing Images 1 & 2.
```{r}
dim(Image1)[1:2]
```

```{r}
# resize images to get to same shape. try '?resize'
Image1 = EBImage::resize(Image1, dim(Image1)[1], output.dim = dim(Image2)[1:2])
print(Image1)
print(Image2)

summary(Image1)
summary(Image2)
```

```{r}
# Display read images
EBImage::display(Image1)
```


```{r}
EBImage::display(Image2)
```

```{r}
# Plot data with 'hist()'
  hist(Image1) # <1 sec
```
Above, we see the number of pixels (along Y-axis) against their intensity (higher is more on 0-1 scale) for each of the tree RGB matrices. Higher intensity gives a lighter or brighter hue.

Because the Images are stired as numeric arrays, standard arithmetic ops like +, -, /, * and square-roots etc. are do-able on them.

Behold.

```{r}
## Manipulating brightness
# Light
a <- Image1 + 0.4
print(a)
EBImage::display(a)
```


```{r}
# Dark
b <- Image1 - 0.4
EBImage::display(b)
hist(b)  # see x-axis on how the values have shifted by 0.4
```

```{r}
# 'combine()' forms a series or set of images
c <- EBImage::combine(Image1, Image2)
EBImage::display(c, all = TRUE)  # makes a series of connected images (frames)
```


```{r}
### Arithmetic ops on image pixel values

# 'adding' two pictures into one
d <- Image1 + Image2
EBImage::display(d)
hist(d)
```

```{r}
## Manipulating contrast - 'multiplying' pixel values
e <- Image1*0.5
EBImage::display(e)  # why's the image coming out darker? Hint: Sqrt of num <1 is > or < num?

f <- Image1*3
EBImage::display(f)
```


```{r}
# overlay and contrast
img_comb = EBImage::combine(
  Image1,
  Image1 + 0.3,
  Image1 * 2,
  Image1 ^ 0.5
)

EBImage::display(img_comb, all=TRUE)
```

Being numeric arrays, images can be conveniently manipulated by any of R's arithmetic operators. For example, we can produce a negative image by simply subtracting the image from its maximum value.

Behold.
```{r}
## Building negatives of an image
img_neg = max(Image1) - Image1
EBImage::display( img_neg )
```

```{r}
## Color modes
colorMode(Image1) <- Grayscale
print(Image1)
EBImage::display(Image1)

# colorMode(Image1) <- Color #to return to color
```


```{r}
colorMode(Image1) <- Color #to return to color

# Cropping
k <- Image1[100:300, 200:300,]
EBImage::display(k)
```

```{r}
## New image file
writeImage(k, "./NewImage.jpg")   # check in wd
```

```{r}
# Flip, Flop, Rotate, resize
l <- flip(Image1)
EBImage::display(l)

m <- rotate(Image1, 45)
EBImage::display(m)

n<- flop(Image1)
EBImage::display(n)

o <- EBImage::resize(Image1, 400)
EBImage::display(o)
```

One may ask - why bother with these simple ops like *cropping or rotating or resizing etc* when you can do them in, heck, MSPaint?

Good Q. What we saw above was merely a demo for one odd image. But what if we have collected not a few but many 100s of images?

Getting things into R or Py has the inherent advantage that we then make the task inherently *programmable, scalable, flexible and integrate-able* into larger work-flows.

There's so much more we can do in image processing but I won't go there for two reasons:

    Quite a bit of theory and math will creep in which will be handled by other courses in later terms.
    The really interesting bits of work with image processing all require some M/L and D/L workflows around them. That will come in good time later on.

For now, you've been introduced to the elementary aspects of image-handling once we've done DC on image data.

### Scraping image search results with imager

Below I demo one neat application of imager - using it to scrape google image search results.

Good that we've covered basic web scraping functionality earlier. I'll invoke **rvest** in what follows.

P.S. Works just the same for Bing etc also, BTW.

```{r}
## Pulling images off of goog search pages

suppressPackageStartupMessages({ 
  
  if (!require(imager)){install.packages("imager")}
  library(imager)  # https://dahtah.github.io/imager/imager.html
  if (!require(rvest)){install.packages("rvest")}
  library(rvest)
  if (!require(magick)){install.packages("magick")}
library(magick)
})

# Run a search query (returning html content)
search <- read_html("https://www.google.com/search?site=&tbm=isch&q=ISB")

# Grab all <img> tags, get their "src" attribute, a URL to an image
urls <- search %>% html_nodes("img") %>% html_attr("src") #Get urls of parrot pictures
length(urls)
urls[1:4]
```

Check out if the original search string 'https://www.google.com/search?site=&tbm=isch&q=ISB' makes sense by directly typing it into a browser. Likewise, check if the urls in the 'urls' object make sense by direct-typing into browser address-bar.

Now that we have the image urls, it should be a simple matter to render them in R, no? Well, truth is that took me a while to figure out. Imager uses CImg standards and to import web scraped images into R, I took a roundabout route of writing them to some temp location and then re-reading from disk.

I'm displaying just 4 images. Using a 'map_imageList' func called map_il() that works like the 'map_xyz' funcs we have in the tidyverse.

Behold, below.

```{r}
require(magick)
load.image1 <- function(url){
  test = image_read(url) %>% magick2cimg(., alpha="flatten")
  return(test)
}

system.time({ map_il(urls[1:4], load.image1) %>% plot })
```

Well, I'll signoff here.

I realize we haven't done video loading and frame capture. Once the frames are captured, we can handle them like any other images. I haven't yet decided to go with it or not coz of time concerns.

Ciao.

Sudhir

